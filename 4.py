# -*- coding: utf-8 -*-
"""04_ДЗ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18mlOFQuY_gzcAlUG8WKGNKlOlstaY2Jf

# Научные вычисления с NumPy

#### Задача 1

Подгрузите файл **train_vector.csv** с помощью функции **np.loadtxt**. Назовите подгруженный массив my_array. Убедитесь, что подгруженный массив имеет тип np.ndarray
"""

from google.colab import files #нужно для загрузки файла
import numpy as np # подгрузка np

file = files.upload() #выбор файла

!ls #проверка подгрузился файл или нет

my_array = np.loadtxt('train_vector.csv', delimiter=',')

type(my_array) #проверка типа

"""#### Задача 2

Возьмите функцию из предыдущих домашних заданий, которая считает сумму всех элементов массива. Примените ее к my_array.
"""

print(my_array)

def sum_of_list(my_list):
    sum_of_elements = 0
    for element in my_list:
        sum_of_elements += element
    return sum_of_elements
  
sum_arry = sum_of_list(my_array)
print(sum_arry)

my_array.sum() #проверка через метод из NP

"""#### Задача 3

Напишите функцию, которая считает среднее значение всех элементов массива. Примените ее к подгруженному массиву my_array.
"""

def Sred_arry(arr):
    arr.sort()
    if len(arr) == 0:
        z = 0
    else:
        sred = sum(arr)/len(arr)       
    return sred

sred_arry = Sred_arry(my_array)
print(sred_arry)

#проверка через методы NP
sred = my_array.mean() 
maxim = my_array.max()
minim = my_array.min()
print("среднее значение ",sred)
print("максимальное значение ",maxim)
print("минимальное значение ",minim)

"""#### Задача 4

Напишите функцию, которая ищет минимальный элемент массива. Примените ее к подгруженному массиву my_array
"""

def printMin(arr):
    arr.sort()     
    if len(arr) == 1:
        arr1 = arr.copy()
        n = arr1.pop(0)
        if n == 0:
            print('min: 0')
            
        else:
            (float(n))
            
    else:
        min(arr)
        
    return min(arr)

min_ = printMin(my_array)
print(min_)

"""#### Задача 5

Сравните производительность по времени с встроенными функциями: 

(В качестве переменной используйте подгруженный ранее массив my_array)
    
* np.sum
* np.mean
* np.min

P.S. используйте %%timeit
"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.sum()

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# sum_of_list(my_array)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.mean()

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# Sred_arry(my_array)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.min()

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# printMin(my_array)

"""#### Задача 6
Преобразуйте исходный массив my_array в список (list). Назовите его my_list. Сравните производительность написанных вами функций в зависимости от типа данных (my_list и my_array). Сделайте вывод
"""

my_list = list(my_array)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# sum_of_list(my_list)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# sum_of_list(my_array)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# Sred_arry(my_list)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# Sred_arry(my_array)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# printMin(my_list)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# printMin(my_array)

"""# Вывод
## у списков идет быстрее обработка в отличие от матриц, но исполььзуя методы из Numpy скорость обработки с их помощью быстрее

#### Задача 7

Сравните производительность написанных вами функций с встроенными функциями на массиве my_list. Сделайте вывод.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# sum_of_list(my_list)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.sum()

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# Sred_arry(my_list)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.mean()

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# printMin(my_list)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.min()

"""# Вывод
## Используя методы из библиотеки NumPy скорость вычислений быстрее

#### Задача 8

Подгрузите файл **iris.csv** с помощью встроенной функции **np.loadtxt**. Назовите его my_2d_array. Напиишите функцию, которая считает сумму элементов массива по столбцам.
"""

my_2d_array = np.loadtxt('iris.csv', delimiter=',')

type(my_2d_array) #проверка типа

def sum_Po_Stol(l):
    return list(map(sum, zip(*l)))
sum_Po_Stol(my_2d_array)

my_2d_array.sum(axis=0) #проверка

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_2d_array.sum(axis=0)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# sum_Po_Stol(my_2d_array)

"""#### Задача 9
* транспонируйте my_2d_array
* выполните матричное умножение my_2d_array на my_2d_array.T
* выполните матричное умножение my_2d_array.T на my_2d_array
"""

#транспонируйте my_2d_array
my_2d_array.T

#выполните матричное умножение my_2d_array на my_2d_array.T
my_2d_array.dot(my_2d_array.T)

#выполните матричное умножение my_2d_array.T на my_2d_array
my_2d_array.T.dot(my_2d_array)

"""#### Задача 10
Найдите в документации библиотеки numpy функцию, вычисляющую собственные числа матрицы.

Найдите собственные числа матриц (my_2d_array.T * my_2d_array) и (my_2d_array * my_2d_array.T) используя соответсующую функцию
"""

import numpy.linalg as linalg

#my_2d_array.T my_2d_array
a = my_2d_array.T.dot(my_2d_array)
vals, vecs = linalg.eig(a)
vals

#my_2d_array my_2d_array.T
b = my_2d_array.dot(my_2d_array.T)
vals2, vecs2 = linalg.eig(b)
vals2

"""### Вариант Pro

#### Задача 1

* Подгрузите массив **iris.csv** и назовите его my_array. 

* В документации библиотеки numpy найдите функцию, генерирующую случаные числа.

* Создайте двумерный массив из случайных чисел той же размерности, что и my_array.

* Назовите его my_generated_array
"""

my_array = np.loadtxt('iris.csv', delimiter=',') #Подгрузите массив iris.csv и назовите его my_array

type(my_array) #проверка типа

my_array.shape #узнаю размерность массива

my_array.max() #узнаю максимальное значение массива

my_array.min() #узнаю минимальное значение массива

#cоздайте двумерный массив из случайных чисел той же размерности и в том же диапазоне чисел, что и my_array
my_generated_array = np.random.uniform(0.1, 7.9, size=(150, 4))   
type(my_generated_array)
print(my_generated_array)

"""#### Задача 2

* Выполните поэлементное умножение my_array на my_generated_array

* Транспонируйте my_generated_array

* Выполните матричное умножение my_array на транспонированный my_generated_array

* Выполните матричное умножение my_array.T на my_generated_array
"""

# поэлементное умножение my_array на my_generated_array
umn_po_elem = my_array*my_generated_array
print(umn_po_elem)

#Транспонируйте my_generated_array
trans = my_generated_array.T
print(trans)

#Выполните матричное умножение my_array на транспонированный my_generated_array
rez_umn_na_trans = my_array.dot(trans)
print(rez_umn_na_trans)

#Выполните матричное умножение my_array.T на my_generated_array
rez_umn =trans.dot(my_array)
print(rez_umn)

"""#### Задача 3

* Найдите все элементы массива my_array, которые больше трех и меньше 5 одновременно. Используйте методологию подвыборки массива с условием
"""

element = my_array[(3<my_array)&(my_array<5)]
print(element)

"""#### Задача 4

Даны два массива. 
* Найдите все общие элементы массивов (пересечение) при помощи встроенного метода.
* Напишите функцию, которая находит пересечение двух массивов (используйте структуру set)
* Сравните производительность по времени между np.intersect и вашей функцией. Для сравнения используйте %%timeit
"""

a = np.array([17, 2, 3, 8, 5, 1990, 23, 36, 74])
b = np.array([37, 32, 12, 3, 25, 0, 17, 96, 54, 1990, 206])

#Найдите все общие элементы массивов (пересечение) при помощи встроенного метода.
obshie = np.intersect1d(a, b)
print(obshie)

#Напишите функцию, которая находит пересечение двух массивов (используйте структуру set)
def per(a, b):
  c = (set(a) & set(b))
  return c
per(a, b)

# Commented out IPython magic to ensure Python compatibility.
# #Сравните производительность по времени между np.intersect 
# %%timeit
# obshie

# Commented out IPython magic to ensure Python compatibility.
# #функция
# %%timeit
# per(a, b)

"""#### Задача 5

Создайте трехмерный массив размера 2 на 3 на 4, состоящий из случайных вещественных чисел от 17 до 23. Используйте встроенные методы библиотеки  np.random...
"""

arr_3D = np.random.randint(17, 24, size=(2, 3, 4))
print(arr_3D)

arr_3D.shape

"""#### Задача 6

Используя массив из предыдущей задачи, преобразуйте его в новый массив со следующими значениями:
    * "small", если значения меньше 19
    * "medium", если значения в промежутке [19, 21]
    * "large", если значения больше 21
"""

#medium
medium = arr_3D[(19<arr_3D)&(arr_3D<22)]
medium

#large
large = arr_3D[arr_3D>21]
large

#small
small = arr_3D[arr_3D<19] 
small

"""#### Задача 7

Преобразуйте массив из задачи 5 в "плоский" массив, т.е. вытяните существующий трехмерный массив в вектор при помощи встроенных методов библиотеки numpy
"""

arr_3D.ravel()

"""#### Задача 8: стандартизация данных

Напишите функцию, которая выполняет стандартизацию данных, т.е. преобразовывает их так, чтобы среднее значение стало равным нулю, а стандартное отклонение единице.

* загуглите что такое стандартизация и найдите формулу
* напишите функцию
* проверьте правильность выполнения функции на массиве из задачи 5
"""

#стандартизация

def sred_arif(data):      #Cреднее арифметическое
    n = len(data)
    if n < 1:
        raise ValueError("Ошибка, нужно хотя бы одно значение")
    return sum(data)/n 

def sum_kvadr(data):            #Возвращает сумму квадратических отклонений данных последовательности
    c = mean(data)
    ss = sum((x-c)**2 for x in data)
    return ss

def stand_Okl(data, ddof=0):   #Рассчитывает стандартное отклонение по умолчанию 0,
                            #укажите ddof = 1 для вычисления образца стандартного отклонения
    n = len(data)
    if n < 2:
        raise ValueError('Дисперсия требует как минимум две точки данных')
    ss = _ss(data)
    pvar = ss/(n-ddof)
    return pvar**0.5
  
sred_arif(arr_3D)
sum_kvadr(arr_3D)
stand_Okl(arr_3D, ddof=1)

"""**Задача 9**

* Напишите функцию, которая выполняет умножение двух матриц.
* Сравните производительность по времени своей функции со встроенным методом .dot
"""

def umn_Mat(a,b):
    zip_b = zip(*b)
    return [[sum(ele_a*ele_b for ele_a, ele_b in zip(row_a, col_b)) 
             for col_b in zip_b] for row_a in a]

umn_Mat(my_array, trans)

#проверка
my_array.dot(trans)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# my_array.dot(trans)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# umn_Mat(my_array, trans)

"""# Вывод
## у метода из Numpy скорость обработки выше
"""